include "mlir/IR/OpBase.td"

def Toy_Dialect : Dialect {
  let name = "toy";
  let cppNamespace = "toy";
}

// Create a base clasee for all Toy dialect operations
class Toy_Op<string mnemonic, list<OpTrait> traits = []> :
    Op<Toy_Dialect, mnemonic, traits>;

// Constant operation with FQN of operation: toy.constant
def ConstantOp : Toy_Op<"constant", [NoSideEffect]> {  // Instantiates Op with: OpTrait::HasNoSideEffect

  // Does not affect Op template arguments
  // Creates: DenseElementsAttr value(); and valueAttrs()
  let arguments = (ins F64ElementsAttr:$value);
  
  // Instantiates Op template with: OpTrait::OneResult
  // Return values can be optionally named, creating an accessor method
  //   F64Tensor is C++ 64-bit TensorType
  let results = (outs F64Tensor);
  
  // Documentation fields
  let summary = "constant operation";
  let  let description = [{ Multi-line text here to describe operation }];
  
  // Some verification is done automatically in an OpName::verify method
  // Below requires you to create a '::verify' C++  function in global namespace,
  // which will be called from OpName::verify method
  let verifier = [{ return ::verify(*this); }];

  // Three Builders are generated by default, create additional through this field
  // Field builders take a list of OpBuilder objects
  let builders = [
    // Call C++ code
    OpBuilder<"OpBuilder &builder, OperationState &result, DenseElementsAttr value", [{
      build(builder, result, value.getType(), value);
    }]>,
    // Requires you to define your own method in C++ with arguments
    OpBuilder<"OpBuilder &builder, OperationState &result, double value">
  ];
  
  
  
}
